// scripts/gen-logs-types.mjs
// Usage:
//   node scripts/gen-logs-types.mjs "/absolute/path/to/information_schema_logs.csv"
// 期待するCSVヘッダー（順不同OK）:
//   ordinal_position, column_name, data_type, is_nullable, column_default
// 出力: types/logs.ts を自動生成（ディレクトリ無ければ作成）

import fs from 'fs';
import path from 'path';

function die(msg, code = 1) {
  console.error(msg);
  process.exit(code);
}

function usage() {
  die(`Usage: node ${path.relative(process.cwd(), process.argv[1])} "/path/to/information_schema_logs.csv"`);
}

const inputPath = process.argv[2];
if (!inputPath) usage();

if (!fs.existsSync(inputPath)) {
  die(`ERROR: file not found -> ${inputPath}`);
}

// --- 小さめCSVパーサ（ダブルクオート対応・CRLF対応） ---
function parseCSV(text) {
  const rows = [];
  let i = 0, field = '', row = [], inQuotes = false;
  const pushField = () => { row.push(field); field = ''; };
  const pushRow = () => { rows.push(row); row = []; };
  while (i < text.length) {
    const ch = text[i];
    if (inQuotes) {
      if (ch === '"') {
        if (text[i + 1] === '"') { field += '"'; i += 2; continue; } // エスケープ
        inQuotes = false; i++; continue;
      } else { field += ch; i++; continue; }
    } else {
      if (ch === '"') { inQuotes = true; i++; continue; }
      if (ch === ',') { pushField(); i++; continue; }
      if (ch === '\n') { pushField(); pushRow(); i++; continue; }
      if (ch === '\r') { // CRLF
        if (text[i + 1] === '\n') i++;
        pushField(); pushRow(); i++; continue;
      }
      field += ch; i++; continue;
    }
  }
  // 最終フィールド
  pushField();
  // 最終行が空行なら落とす
  if (row.length === 1 && row[0] === '') rows.pop();
  else if (row.length) rows.push(row);
  return rows;
}

const raw = fs.readFileSync(inputPath, 'utf8');
const rows = parseCSV(raw);
if (rows.length < 2) die('ERROR: CSV has no data rows');

const header = rows[0].map(h => h.trim().toLowerCase());
const dataRows = rows.slice(1);

// 必須ヘッダーのインデックス解決（順不同OK）
function colIdx(name) {
  const i = header.indexOf(name);
  if (i === -1) die(`ERROR: CSV header missing: ${name}`);
  return i;
}
const idxOrdinal = header.includes('ordinal_position') ? colIdx('ordinal_position') : null; // 任意
const idxName     = colIdx('column_name');
const idxType     = colIdx('data_type');
const idxNullable = colIdx('is_nullable');
const idxDefault  = header.includes('column_default') ? colIdx('column_default') : null;

// Postgres→TypeScript ざっくりマッピング
function pgToTs(baseTypeRaw) {
  const t = baseTypeRaw.toLowerCase();
  if (t.includes('boolean')) return 'boolean';
  if (t.includes('int') || t.includes('smallint') || t.includes('integer')) return 'number';
  if (t.includes('bigint')) return 'string'; // bigintは文字列に寄せる方が安全
  if (t.includes('numeric') || t.includes('decimal') || t.includes('real') || t.includes('double')) return 'number';
  if (t.includes('timestamp') || t === 'date' || t.includes('time')) return 'string'; // ISO文字列想定
  if (t.includes('uuid')) return 'string';
  if (t.includes('json')) return 'any';
  if (t.includes('text') || t.includes('char') || t.includes('varchar')) return 'string';
  if (t.includes('array')) return 'any[]'; // information_schema.data_type が ARRAY の場合
  return 'any';
}

function clean(s) {
  return (s ?? '').trim();
}

const cols = dataRows
  .map(r => {
    const name = clean(r[idxName]);
    const dataType = clean(r[idxType]);
    const isNullable = clean(r[idxNullable]).toUpperCase() === 'YES';
    const hasDefault = idxDefault !== null ? clean(r[idxDefault]) !== '' : false;
    const ord = idxOrdinal !== null ? Number(clean(r[idxOrdinal]) || '0') : 0;
    return { ord, name, dataType, isNullable, hasDefault };
  })
  .filter(c => c.name) // 念のため
  .sort((a, b) => a.ord - b.ord); // 出力を列順に

// 型組み立て
function rowPropType(c) {
  const base = pgToTs(c.dataType);
  return c.isNullable ? `${base} | null` : base;
}
function insertPropType(c) {
  // Insert型では null 許容は付けず、ベース型にする
  return pgToTs(c.dataType);
}
function updatePropType(c) {
  // Update型は全部任意、null入れたいならAPI側で調整
  return `${pgToTs(c.dataType)} | null`;
}

// Insert 必須判定: NOT NULL かつ DEFAULTなし → 必須、それ以外は任意
function isInsertRequired(c) {
  return !c.isNullable && !c.hasDefault;
}

// 出力生成
const now = new Date().toISOString();
const out = `/* eslint-disable */
// AUTO-GENERATED by scripts/gen-logs-types.mjs
// Source CSV : ${inputPath}
// Generated   : ${now}

export const LOGS_TABLE = 'logs' as const;

export type LogsRow = {
${cols.map(c => `  ${JSON.stringify(c.name)}: ${rowPropType(c)};`).join('\n')}
};

export type LogsInsert = {
${cols.map(c => `  ${JSON.stringify(c.name)}${isInsertRequired(c) ? '' : '?'}: ${insertPropType(c)};`).join('\n')}
};

export type LogsUpdate = {
${cols.map(c => `  ${JSON.stringify(c.name)}?: ${updatePropType(c)};`).join('\n')}
};

// Column meta (optional helper)
export const LogsColumns = [
${cols.map(c => `  { name: ${JSON.stringify(c.name)}, dataType: ${JSON.stringify(c.dataType)}, nullable: ${c.isNullable}, hasDefault: ${c.hasDefault} }`).join(',\n')}
] as const;
`;

// 出力先作成＆書き込み
const outDir = path.resolve('types');
fs.mkdirSync(outDir, { recursive: true });
const outFile = path.join(outDir, 'logs.ts');
fs.writeFileSync(outFile, out, 'utf8');

console.log(`Wrote ${path.relative(process.cwd(), outFile)} with ${cols.length} columns.`);

